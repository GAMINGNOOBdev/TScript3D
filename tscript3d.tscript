###
### 3D rendering library for tscript
### Loosely based on the glm library (https://github.com/g-truc/glm) and on the
### basic concept of OpenGL.
###
### GLM License:
# ================================================================================
# OpenGL Mathematics (GLM)
# --------------------------------------------------------------------------------
# GLM is licensed under The Happy Bunny License or MIT License

# ================================================================================
# The Happy Bunny License (Modified MIT License)
# --------------------------------------------------------------------------------
# Copyright (c) 2005 - G-Truc Creation

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# Restrictions:
#  By making use of the Software for military purposes, you choose to make a
#  Bunny unhappy.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

# ================================================================================
# The MIT License
# --------------------------------------------------------------------------------
# Copyright (c) 2005 - G-Truc Creation

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
###
###
### TSCRIPT3D LICENSE:
###
###
# MIT License
#
# Copyright (c) 2025 GAMINGNOOBdev
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE. 

namespace glm
{
    function copyData(data)
    {
        if Type(data) == glm.vec then
            return deepcopy(data.data);
        
        return deepcopy(data);
    }

    class vec
    {
    public:
        var dimensions = 0;
        var data = [];

        constructor(input,scalar=null)
        {
            if Type(input) == Array then
            {
                dimensions = input.size();
                data = deepcopy(input);
            }
            else if Type(input) == vec then
            {
                dimensions = input.dimensions;
                data = deepcopy(input.data);
            }
            else if scalar != null then
            {
                dimensions = input;
                data = [];
                for 0:input do
                    data.push(scalar);
            }
            else
            {
                dimensions = input;
                data = [];
                for 0:input do
                    data.push(0);
            }
        }

        function add(other)
        {
            if Type(other) != vec then return;
            if other.dimensions != dimensions then
                return;

            var result = vec(dimensions);

            for var i in 0:dimensions do
                result.data[i] = data[i] + other.data[i];

            return result;
        }

        function sub(other)
        {
            if Type(other) != vec then return;
            if other.dimensions != dimensions then
                return;
            
            return add(other.mul(-1.0));
        }

        function mul(other)
        {
            if Type(other) != vec then
            {
                var result = vec(dimensions);
                for var i in 0:dimensions do
                    result.data[i] = data[i] * other;
                return result;
            }

            if other.dimensions != dimensions then
                return;
            
            var result = vec(dimensions);
            for var i in 0:dimensions do
                result.data[i] = data[i] * other.data[i];
            return result;
        }

        function dot(other)
        {
            if Type(other) != vec then return;
            if other.dimensions != dimensions then
                return;

            var sum = 0;
            for var i in 0:dimensions do
                sum += data[i] * other.data[i];
            return sum;
        }

        function cross(other)
        {
            if Type(other) != vec then return;
            if other.dimensions != dimensions and dimensions != 3 then
                return;

            var newvec = [
                data[1]*other.data[2] - other.data[1]*data[2],
                data[2]*other.data[0] - other.data[2]*data[0],
                data[0]*other.data[1] - other.data[0]*data[1],
            ];
            return vec(newvec);
        }

        function normalized()
        {
            var result = vec(dimensions);
            var len = length();
            for var i in 0:dimensions do
                result.data[i] = data[i] / len;
            return result;
        }

        function length()
        {
            var sum = 0;
            for var i in 0:dimensions do
                sum += data[i]^2;
            return math.sqrt(sum);
        }

        function printvec()
        {
            var string = "dimensions: " + dimensions + " | contents: [";
            for var i in 0:dimensions do
                string += data[i] + ",";
            string += "]";
            print(string);
        }
    }

    class mat4
    {
    public:
        var data;

    public:
        constructor(scalar,row2=null,row3=null,row4=null)
        {
            if row4 != null then
            {
                data = [
                    copyData(scalar),
                    copyData(row2),
                    copyData(row3),
                    copyData(row4)
                ];
            }
            else
            {
                var size = 4;

                data = [];
                for var y in 0:size do
                {
                    var row = [];
                    for var x in 0:size do
                    {
                        var val = 0;
                        if x == y then val = scalar;
                        row.push(val);
                    }
                    data.push(row);
                }
            }
        }

        function mul(other)
        {
            if Type(other) != mat4 and Type(other) != vec then
                return;

            if Type(other) == vec then
            {
                var vector = vec(other.data);
                if other.dimensions != 4 then
                {
                    var remaining = 4 - other.dimensions;
                    vector.dimensions = 4;
                    for 0:remaining do
                        vector.data.push(1);
                }
                var result = vec(4,0);
                for var i in 0:4 do
                    for var j in 0:4 do
                        result.data[i] += vector.data[j]*data[j][i];
                return result;
            }

            var SrcA0 = data[0];
            var SrcA1 = data[1];
            var SrcA2 = data[2];
            var SrcA3 = data[3];

            var SrcB0 = other.data[0];
            var SrcB1 = other.data[1];
            var SrcB2 = other.data[2];
            var SrcB3 = other.data[3];

            var tmp0 = fma(
                SrcA3,
                splatW(SrcB0),
                fma(
                    SrcA2,
                    splatZ(SrcB0),
                    fma(
                        SrcA1,
                        splatY(SrcB0),
                        vec(SrcA0).mul(splatX(SrcB0))
                    )
                )
            );
            var tmp1 = fma(
                SrcA3,
                splatW(SrcB1),
                fma(
                    SrcA2,
                    splatZ(SrcB1),
                    fma(
                        SrcA1,
                        splatY(SrcB1),
                        vec(SrcA0).mul(splatX(SrcB1))
                    )
                )
            );
            var tmp2 = fma(
                SrcA3,
                splatW(SrcB2),
                fma(
                    SrcA2,
                    splatZ(SrcB2),
                    fma(
                        SrcA1,
                        splatY(SrcB2),
                        vec(SrcA0).mul(splatX(SrcB2))
                    )
                )
            );
            var tmp3 = fma(
                SrcA3,
                splatW(SrcB3),
                fma(
                    SrcA2,
                    splatZ(SrcB3),
                    fma(
                        SrcA1,
                        splatY(SrcB3),
                        vec(SrcA0).mul(splatX(SrcB3))
                    )
                )
            );

            return mat4(tmp0, tmp1, tmp2, tmp3);
        }

        static function copy(other)
        {
            return mat4(other.data[0], other.data[1], other.data[2], other.data[3]);
        }
    }

    var vec2 = function(x,y){return vec([x,y]);};
    var vec3 = function(x,y,z){return vec([x,y,z]);};
    var vec4 = function(x,y,z,w){return vec([x,y,z,w]);};

    function radians(angle)
    {
        return angle / 180.0 * math.pi();
    }

    function fma(a, b, c)
    {
        return vec(a).mul(vec(b)).add(vec(c));
    }

    function splatX(a)
    {
        var vector = vec(a);
        if vector.dimensions < 1 then return;
        return vec(vector.dimensions, vector.data[0]);
    }

    function splatY(a)
    {
        var vector = vec(a);
        if vector.dimensions < 2 then return;
        return vec(vector.dimensions, vector.data[1]);
    }

    function splatZ(a)
    {
        var vector = vec(a);
        if vector.dimensions < 3 then return;
        return vec(vector.dimensions, vector.data[2]);
    }

    function splatW(a)
    {
        var vector = vec(a);
        if vector.dimensions < 4 then return;
        return vec(vector.dimensions, vector.data[3]);
    }

    function convertToScreenSpace(point, width, height)
    {
        if point.dimensions < 4 then return vec3(0,0,0);
        var x = point.data[0];
        var y = point.data[1];
        var z = point.data[2];
        var w = point.data[3];

        if w == 0.0 then return vec3(0,0,0);

        var normalizedPoint = vec([x/w, y/w, z/w]).add(vec(3,1)).mul(0.5);
        return normalizedPoint.mul(vec([width, height, 1]));
    }

    function ortho(left, right, bottom, top, near, far)
    {
        var result = mat4(1);
        result.data[0][0] = 2.0 / (right - left);
        result.data[1][1] = 2.0 / (top - bottom);
        result.data[2][2] = - 2.0 / (far - near);
        result.data[3][0] = - (right + left) / (right - left);
        result.data[3][1] = - (top + bottom) / (top - bottom);
        result.data[3][2] = - (far + near) / (far - near);
        return result;
    }

    function perspective(fovy, aspect, near, far)
    {
        var tanHalfFovy = math.tan(fovy / 2.0);
        var result = mat4(0);

        result.data[0][0] = 1.0 / (aspect * tanHalfFovy);
        result.data[1][1] = 1.0 / (tanHalfFovy);
        result.data[2][2] = - (far + near) / (far - near);
        result.data[2][3] = -1.0;
        result.data[3][2] = - (2.0 * far * near) / (far - near);
        return result;
    }

    function translate(m, v)
    {
        var result = mat4.copy(m);
        var row0 = vec(m.data[0]).mul(v.data[0]);
        var row1 = vec(m.data[1]).mul(v.data[1]);
        var row2 = vec(m.data[2]).mul(v.data[2]);
        var row3 = vec(m.data[3]);
        result.data[3] = row0.add(row1).add(row2).add(row3).data;
        return result;
    }

    function rotate(m, angle, v)
    {
        var a = angle;
        var c = math.cos(a);
        var s = math.sin(a);

        var axis = v.normalized();
        var temp = axis.mul(1.0 - c);

        var Rotate = mat4(0);
        Rotate.data[0][0] = c + temp.data[0] * axis.data[0];
        Rotate.data[0][1] = temp.data[0] * axis.data[1] + s * axis.data[2];
        Rotate.data[0][2] = temp.data[0] * axis.data[2] - s * axis.data[1];

        Rotate.data[1][0] = temp.data[1] * axis.data[0] - s * axis.data[2];
        Rotate.data[1][1] = c + temp.data[1] * axis.data[1];
        Rotate.data[1][2] = temp.data[1] * axis.data[2] + s * axis.data[0];

        Rotate.data[2][0] = temp.data[2] * axis.data[0] + s * axis.data[1];
        Rotate.data[2][1] = temp.data[2] * axis.data[1] - s * axis.data[0];
        Rotate.data[2][2] = c + temp.data[2] * axis.data[2];

        var result = mat4(0);
        var m0 = vec(m.data[0]);
        var m1 = vec(m.data[1]);
        var m2 = vec(m.data[2]);
        result.data[0] = m0.mul(Rotate.data[0][0]).add( m1.mul(Rotate.data[0][1]) ).add( m2.mul(Rotate.data[0][2]) ).data;
        result.data[1] = m0.mul(Rotate.data[1][0]).add( m1.mul(Rotate.data[1][1]) ).add( m2.mul(Rotate.data[1][2]) ).data;
        result.data[2] = m0.mul(Rotate.data[2][0]).add( m1.mul(Rotate.data[2][1]) ).add( m2.mul(Rotate.data[2][2]) ).data;
        result.data[3] = deepcopy(m.data[3]);
        return result;
    }

    function scale(m, v)
    {
        var result = mat4(0);
        var m0 = vec(m.data[0]);
        var m1 = vec(m.data[1]);
        var m2 = vec(m.data[2]);
        result.data[0] = m0.mul(v.data[0]).data;
        result.data[1] = m1.mul(v.data[1]).data;
        result.data[2] = m2.mul(v.data[2]).data;
        result.data[3] = deepcopy(m.data[3]);
        return result;
    }

    function lookAt(eye, center, up)
    {
        var f = center.sub( eye ).normalized();
        var s = f.cross(up).normalized();
        var u = s.cross(f);

        var result = mat4(1);
        result.data[0][0] = s.data[0];
        result.data[1][0] = s.data[1];
        result.data[2][0] = s.data[2];
        result.data[0][1] = u.data[0];
        result.data[1][1] = u.data[1];
        result.data[2][1] = u.data[2];
        result.data[0][2] =-f.data[0];
        result.data[1][2] =-f.data[1];
        result.data[2][2] =-f.data[2];
        result.data[0][3] =-s.dot(eye);
        result.data[1][3] =-u.dot(eye);
        result.data[2][3] =-f.dot(eye);
        return result;
    }

    function calculateTriangles(numTriangles, buffer, projection, view, model, width, height)
    {
        var triangles = [];
        var combinedMatrix = projection.mul(model);

        for var i in 0:numTriangles do
        {
            var p0 = convertToScreenSpace(combinedMatrix.mul(buffer[i*3]), width, height);
            var p1 = convertToScreenSpace(combinedMatrix.mul(buffer[i*3+1]), width, height);
            var p2 = convertToScreenSpace(combinedMatrix.mul(buffer[i*3+2]), width, height);
            triangles.push([p0,p1,p2]);
        }

        triangles.sort(function(lhs,rhs){
            var lhsW = lhs[0].data[2]+lhs[1].data[2]+lhs[2].data[2];
            lhsW /= 3.0;
            var rhsW = rhs[0].data[2]+rhs[1].data[2]+rhs[2].data[2];
            rhsW /= 3.0;
            return lhsW - rhsW;
        });

        return triangles;
    }

}

namespace gl
{
    var backbuffer = canvas.Bitmap(canvas.width(), canvas.height());
    var backbufferSize = [canvas.width(), canvas.height()];
    var glDrawCmds = [ [0,0], [0,0], [0,0] ];

    var glCachedMaxTris = 10000;
    var glDepthBuffer = Array(glCachedMaxTris);
    var glIndexBuffer = Array(glCachedMaxTris);
    var glVertexDisplayCoordinateBuffer = Array(glCachedMaxTris * 6);

    function glBeginDraw()
    {
        canvas.paintImage(0, 0, backbuffer);
        if backbufferSize[0] != canvas.width() or backbufferSize[1] != canvas.height() then
        {
            backbuffer = canvas.Bitmap(canvas.width(), canvas.height());
            backbufferSize = [canvas.width(), canvas.height()];
        }

        canvas.setDrawingTarget(backbuffer);
    }

    function glEndDraw()
    {
        canvas.setDrawingTarget(null);
    }

    function glDrawTrianglesSlowButPretty(numTriangles, buffer, projection, model)
    {
        var triangles = [];
        var combinedMatrix = projection.mul(model);
        var nearPlane = projection.data[3][2] / (projection.data[2][2] - 1.0);
        var w = backbufferSize[0];
        var h = backbufferSize[1];
        var triangleCount = 0;
        var indices = [];
        var zBuffer = [];

        for var i in 0:numTriangles do
        {
            var c0 = combinedMatrix.mul(buffer[i*3]);
            var c1 = combinedMatrix.mul(buffer[i*3+1]);
            var c2 = combinedMatrix.mul(buffer[i*3+2]);

            if c0.data[3] < nearPlane or c1.data[3] < nearPlane or c2.data[3] < nearPlane then
                continue;

            var p0 = glm.convertToScreenSpace(c0, w, h);
            var p1 = glm.convertToScreenSpace(c1, w, h);
            var p2 = glm.convertToScreenSpace(c2, w, h);

            var x0 = p0.data[0];
            var y0 = p0.data[1];
            var x1 = p1.data[0];
            var y1 = p1.data[1];
            var x2 = p2.data[0];
            var y2 = p2.data[1];

            var area = (x1 - x0)*(y2 - y0) -  (x2 - x0)*(y1 - y0);
            if area <= 0 then continue;
            var zSum = c0.data[3] + c1.data[3] + c2.data[3];

            triangles.push(x0);
            triangles.push(y0);
            triangles.push(x1);
            triangles.push(y1);
            triangles.push(x2);
            triangles.push(y2);
            indices.push(triangleCount);
            zBuffer.push(zSum);
            triangleCount += 1;
        }

        indices.sort(function [zBuffer] (lhs,rhs){
            return zBuffer[rhs] - zBuffer[lhs];
        });

        canvas.setFillColor(1,1,1,1);
        for var i in 0:triangleCount do
        {
            var idx = indices[i] * 6;

            glDrawCmds[0][0] = triangles[idx + 0];
            glDrawCmds[0][1] = triangles[idx + 1];
            glDrawCmds[1][0] = triangles[idx + 2];
            glDrawCmds[1][1] = triangles[idx + 3];
            glDrawCmds[2][0] = triangles[idx + 4];
            glDrawCmds[2][1] = triangles[idx + 5];
            canvas.fillArea(glDrawCmds);
        }

    }

    function glDrawTriangles(numTriangles, buffer, projection, model)
    {
        if numTriangles > glCachedMaxTris then
        {
            glCachedMaxTris = numTriangles + 5000;
            glDepthBuffer = Array(glCachedMaxTris);
            glIndexBuffer = Array(glCachedMaxTris);
            glVertexDisplayCoordinateBuffer = Array(glCachedMaxTris * 6);
        }

        var combinedMatrix = projection.mul(model);
        var d = combinedMatrix.data;
        var m00 = d[0][0]; var m01 = d[0][1]; var m03 = d[0][3];
        var m10 = d[1][0]; var m11 = d[1][1]; var m13 = d[1][3];
        var m20 = d[2][0]; var m21 = d[2][1]; var m23 = d[2][3];
        var m30 = d[3][0]; var m31 = d[3][1]; var m33 = d[3][3];

        var pData = projection.data;
        var nearPlane = pData[3][2] / (pData[2][2] - 1.0);

        var w2 = backbufferSize[0] * 0.5;
        var h2 = backbufferSize[1] * 0.5;
        var triangleCount = 0;

        for var i in 0:numTriangles do
        {
            var idx = i * 3;
            var v0 = buffer[idx];
            var v1 = buffer[idx+1];
            var v2 = buffer[idx+2];

            var x0 = v0.data[0];
            var y0 = v0.data[1];
            var z0 = v0.data[2];
            var x1 = v1.data[0];
            var y1 = v1.data[1];
            var z1 = v1.data[2];
            var x2 = v2.data[0];
            var y2 = v2.data[1];
            var z2 = v2.data[2];

            var c0_w = x0 * m03 + y0 * m13 + z0 * m23 + m33;
            if c0_w < nearPlane then
                continue;
            var c0_x = x0 * m00 + y0 * m10 + z0 * m20 + m30;
            var c0_y = x0 * m01 + y0 * m11 + z0 * m21 + m31;
            
            var c1_w = x1 * m03 + y1 * m13 + z1 * m23 + m33;
            if c1_w < nearPlane then
                continue;
            var c1_x = x1 * m00 + y1 * m10 + z1 * m20 + m30;
            var c1_y = x1 * m01 + y1 * m11 + z1 * m21 + m31;

            var c2_w = x2 * m03 + y2 * m13 + z2 * m23 + m33;
            if c2_w < nearPlane then
                continue;
            var c2_x = x2 * m00 + y2 * m10 + z2 * m20 + m30;
            var c2_y = x2 * m01 + y2 * m11 + z2 * m21 + m31;

            var invW0 = 1.0 / c0_w;
            var p0_x = (c0_x * invW0 + 1.0) * w2;
            var p0_y = (c0_y * invW0 + 1.0) * h2;
            var invW1 = 1.0 / c1_w;
            var p1_x = (c1_x * invW1 + 1.0) * w2;
            var p1_y = (c1_y * invW1 + 1.0) * h2;
            var invW2 = 1.0 / c2_w;
            var p2_x = (c2_x * invW2 + 1.0) * w2;
            var p2_y = (c2_y * invW2 + 1.0) * h2;

            var area = (p1_x - p0_x) * (p2_y - p0_y) - (p2_x - p0_x) * (p1_y - p0_y);
            if area <= 0 then continue;

            glDepthBuffer[triangleCount] = c0_w + c1_w + c2_w;
            glIndexBuffer[triangleCount] = triangleCount;

            var ptr = triangleCount * 6;
            glVertexDisplayCoordinateBuffer[ptr + 0] = p0_x;
            glVertexDisplayCoordinateBuffer[ptr + 1] = p0_y;
            glVertexDisplayCoordinateBuffer[ptr + 2] = p1_x;
            glVertexDisplayCoordinateBuffer[ptr + 3] = p1_y;
            glVertexDisplayCoordinateBuffer[ptr + 4] = p2_x;
            glVertexDisplayCoordinateBuffer[ptr + 5] = p2_y;

            triangleCount += 1;
        }

        var sortedTriangles = glIndexBuffer.slice(0, triangleCount);
        
        sortedTriangles.sort(function [glDepthBuffer] (a, b) {
            return glDepthBuffer[b] - glDepthBuffer[a];
        });

        canvas.setFillColor(1,1,1,1);
        for var k in 0:triangleCount do
        {
            var triIdx = sortedTriangles[k];
            var ptr = triIdx * 6;

            glDrawCmds[0][0] = glVertexDisplayCoordinateBuffer[ptr + 0];
            glDrawCmds[0][1] = glVertexDisplayCoordinateBuffer[ptr + 1];
            glDrawCmds[1][0] = glVertexDisplayCoordinateBuffer[ptr + 2];
            glDrawCmds[1][1] = glVertexDisplayCoordinateBuffer[ptr + 3];
            glDrawCmds[2][0] = glVertexDisplayCoordinateBuffer[ptr + 4];
            glDrawCmds[2][1] = glVertexDisplayCoordinateBuffer[ptr + 5];

            canvas.fillArea(glDrawCmds);
        }
    }
}


